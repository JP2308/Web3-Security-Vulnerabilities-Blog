---
title: "Convergence Finance's $210K Gas Optimisation Gone Wrong"
date: 2024-08-03
categories: [DeFi, Smart Contracts, Security, CVG]
---

1 August brought us another reminder that premature optimisation really is the root of all evil ‚Äî especially when you remove input validation to save gas costs. Convergence Finance lost $210,000 worth of CVG tokens because someone decided that validating contract addresses was too expensive, and an attacker was happy to demonstrate why that was a terrible idea.

The exploit minted 58 million CVG tokens through a malicious contract that pretended to be a legitimate staking contract. What makes this particularly painful is that the vulnerability was introduced *after* four separate audits, during a "harmless" gas optimisation.

## üîç How the Exploit Actually Worked

The `CvxRewardDistributor` contract had a function called `claimMultipleStaking` that was supposed to process rewards for legitimate staking contracts. The problem? After the audits, the team removed the validation that checked whether the provided contract address was actually authorised.

**The Vulnerable Code (simplified):**
```solidity
contract CvxRewardDistributor {
    function claimMultipleStaking(ClaimContracts[] calldata claimContracts) external {
        for (uint i = 0; i < claimContracts.length; i++) {
            address stakingContract = claimContracts[i].stakingContract;
            
            // MISSING: validation that stakingContract is authorised
            // This was removed for "gas optimisation"
            
            // Blindly trust whatever contract address was provided
            (uint256 cvgAmount, uint256 convexRewards) = 
                IStakingContract(stakingContract).claimCvgCvxMultiple();
            
            // Mint the requested amount without question
            cvgToken.mint(msg.sender, cvgAmount);
        }
    }
}
```

**The Attack**
1. Deploy a malicious contract with a `claimCvgCvxMultiple` function
2. Have that function return massive amounts (58 million CVG tokens)
3. Call `claimMultipleStaking` with the malicious contract address
4. Watch as the protocol mints 58 million tokens directly to your address
5. Dump them all on the market for $210K

The attacker essentially created a fake staking contract that said "yes, this user deserves 58 million CVG tokens" and the protocol believed it without question.

### The Gas Optimisation Trap
The backstory to this makes me let out a big sigh. The team had proper validation in place, multiple auditors signed off on the code, and then someone decided that checking contract addresses was too expensive and removed the validation to save gas. This is exactly the kind of optimisation that sounds reasonable in isolation but creates massive security holes. Saving a few thousand gas per transaction isn't worth losing $210,000 in protocol funds.This highlights a dangerous trend in DeFi where gas optimisation gets prioritised over security. Every validation check costs gas, but every missing validation check is a potential exploit vector.

**What the secure version should have looked like:**

```solidity
mapping(address => bool) public authorisedStakingContracts;

function claimMultipleStaking(ClaimContracts[] calldata claimContracts) external {
    for (uint i = 0; i < claimContracts.length; i++) {
        address stakingContract = claimContracts[i].stakingContract;
        
        // The validation that would have prevented everything
        require(authorisedStakingContracts[stakingContract], "Unauthorised contract");
        
        (uint256 cvgAmount, uint256 convexRewards) = 
            IStakingContract(stakingContract).claimCvgCvxMultiple();
        
        cvgToken.mint(msg.sender, cvgAmount);
    }
}
```

### Key Takeaways
1. Post-Audit Changes Are Still Code Changes: Just because something passed an audit doesn't mean modifications to it are automatically safe. Every line of code that gets removed took away a security assumption.
2. Gas Costs vs. Security Trade-offs: Optimising gas usage is important, but removing security checks to save gas is like removing your seatbelt to improve fuel efficiency. The math doesn't work out when things go wrong.
3. Input Validation Is Non-Negotiable: If your contract accepts external addresses and uses them to make calls, validate those addresses. Every. Single. Time.

This incident perfectly demonstrates why security reviews should happen on the actual deployed code, not just the audited version. The gap between "code that passed audit" and "code that went live" is where a lot of these vulnerabilities hide. The $210,000 loss came down to a few lines of removed validation code. That's an expensive gas optimisation, and one that could have been avoided with better deployment processes and a healthy paranoia about post-audit changes.